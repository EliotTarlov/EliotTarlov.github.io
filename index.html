<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Homunculus</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; }
        canvas { width: 100vw; height: 100vh; display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; pointer-events: none; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 4px; font-size: 12px; }
    </style>
</head>
<body>
    <div id="ui">Scroll to Zoom | Drag to Pan</div>
    <canvas id="glCanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">#version 300 es
        in vec4 position;
        void main() { gl_Position = position; }
    </script>

    <!-- Runs at fixed simulation resolution -->
    <script id="fs-buffer-a" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        uniform vec3 iResolution;
        uniform int iFrame;
        uniform sampler2D iChannel0;
        out vec4 fragColor;

        int survivalBitMask = (1<<3)+(1<<2);
        int birthBitMask = (1<<3);

        int cell(ivec2 p) {
            ivec2 r = ivec2(textureSize(iChannel0, 0));
            p = (p + r) % r; 
            return (texelFetch(iChannel0, p, 0).x > 0.5) ? 1 : 0;
        }

        float hash1(float n) { return fract(sin(n) * 138.5453123); }

        void main() {
            ivec2 px = ivec2(gl_FragCoord.xy);
            int neighbors = cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))
                          + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))
                          + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));
            
            int alive = cell(px);
            int neighborsBitMask = 1 << neighbors;
            float f = (((alive==1) && ((neighborsBitMask & survivalBitMask)!=0))
                        || ((neighborsBitMask & birthBitMask)!=0)) ? 1.0 : 0.0;
            
            if(iFrame < 2) {
                f = step(0.9, hash1(gl_FragCoord.x * 13.0 + hash1(gl_FragCoord.y * 71.1)));
            }
            fragColor = vec4(f, 0.0, 0.0, 1.0);
        }
    </script>

    <!-- viewport, handles zoom and pan -->
    <script id="fs-main" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        uniform vec3 iResolution;      // Canvas size
        uniform vec2 iSimResolution;   // Simulation texture size
        uniform sampler2D iChannel0;
        uniform float u_zoom;
        uniform vec2 u_offset;
        out vec4 fragColor;

        void main() {
            // Convert screen pixels to 0.0 -> 1.0 UV space
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            
            // apply zoom and offset
            // adjust for aspect ratio so pixels stay square
            float aspect = iResolution.x / iResolution.y;
            vec2 camUV = uv;
            camUV.x *= aspect; 
            camUV = (camUV * u_zoom) + u_offset;
            
            // convert to integer texels of the simulation grid
            ivec2 texelCoords = ivec2(camUV * iSimResolution.y);
            
            // wrapping logic for display
            ivec2 r = ivec2(iSimResolution);
            texelCoords = (texelCoords % r + r) % r;

            float val = texelFetch(iChannel0, texelCoords, 0).x;
            fragColor = vec4(vec3(val), 1.0);
        }
    </script>

    <script>
        const canvas = document.querySelector('#glCanvas');
        const gl = canvas.getContext('webgl2');

        const SIM_RES = [1920, 1080]; // Fixed game board size
        let zoom = 1.0;
        let offset = [0.0, 0.0];
        let isDragging = false;
        let lastMouse = [0, 0];

        function createProgram(vsId, fsId) {
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, document.getElementById(vsId).text); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, document.getElementById(fsId).text); gl.compileShader(fs);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs); gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            return prog;
        }

        const progBufferA = createProgram('vs', 'fs-buffer-a');
        const progMain = createProgram('vs', 'fs-main');

        // Full-screen quad
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // the game board is handled as a texture
        let textures = [], fbos = [];
        for(let i=0; i<2; i++) {
            textures[i] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, textures[i]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, SIM_RES[0], SIM_RES[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            fbos[i] = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textures[i], 0);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        canvas.addEventListener('wheel', e => {
            const zoomSpeed = 0.1;
            const delta = e.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            zoom *= delta;
        });

        canvas.addEventListener('mousedown', e => { isDragging = true; lastMouse = [e.clientX, e.clientY]; });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = (e.clientX - lastMouse[0]) / canvas.height;
            const dy = (e.clientY - lastMouse[1]) / canvas.height;
            offset[0] -= dx * zoom;
            offset[1] += dy * zoom;
            lastMouse = [e.clientX, e.clientY];
        });

        let frame = 0;
        let readIdx = 0;

        function render() {
            const writeIdx = 1 - readIdx;

            // simulation pass
            gl.useProgram(progBufferA);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[writeIdx]);
            gl.viewport(0, 0, SIM_RES[0], SIM_RES[1]);
            gl.uniform3f(gl.getUniformLocation(progBufferA, "iResolution"), SIM_RES[0], SIM_RES[1], 1);
            gl.uniform1i(gl.getUniformLocation(progBufferA, "iFrame"), frame);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[readIdx]);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // display pass
            gl.useProgram(progMain);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniform3f(gl.getUniformLocation(progMain, "iResolution"), canvas.width, canvas.height, 1);
            gl.uniform2f(gl.getUniformLocation(progMain, "iSimResolution"), SIM_RES[0], SIM_RES[1]);
            gl.uniform1f(gl.getUniformLocation(progMain, "u_zoom"), zoom);
            gl.uniform2f(gl.getUniformLocation(progMain, "u_offset"), offset[0], offset[1]);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[writeIdx]);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            readIdx = writeIdx;
            frame++;
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>  
